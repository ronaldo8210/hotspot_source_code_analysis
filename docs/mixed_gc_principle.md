混合回收分为4个阶段：
初始化标记阶段
并发标记阶段
再标记阶段
垃圾回收阶段


在并发标记阶段，因为应用还在运行，所以可能会有引用变更，包括现有引用指向别的对象，或者删除了一个引用，或者创建了一个新的对象等。

无非就是：新建、删除、更新三种情况。

并发标记阶段，引用的变化有5种：

1、new一个对象，新对象被某个老对象引用。新对象直接作为黑色对象；

2、一个对象，被A对象引用时，又被B对象引用，这种情况不会出现漏标；

3、一个灰对象引用了A，但不再引用了，原引用置为null，原来的映射关系（引用A）要被SATB记录下来，但造成了浮动垃圾，A下一次才会被认为是白对象；

4、一个灰对象引用了A，但不再引用了，A改为被另一个灰对象引用，SATB可防止漏标；

5、一个灰对象引用了A，但不再引用了，A改为被另一个黑对象引用，SATB可防止漏标。


三色标记

1、在本轮标记期间新生成的对象，全部作为黑色对象处理（可能要根据SATB指针的位置判断），本轮不会被回收；

2、对于引用变化造成的错标，本轮可以忍受；

3、对于漏标，解决方式是，在并发标记过程中，如果java应用线程更改了一个灰色对象的引用，则原来的引用对象要被记录下来，原理就是SATB，意思就是尽量维持并发标记开始时刻的整体内存的原有样子，即快照。


CMTask处理Stack，是因为使用深度优先遍历

每个region都有自己的pTAMS、nTAMS，与书上说的一样

CMTask的_finger，指向上一次被标记的对象的下一个地址

要扫描全部年轻代存活的对象，以当前年轻代存活的对象为根，去标记老年代的对象。因为从年轻代到老年代没有RSet，所以必须扫描所有的年轻代对象。

并发标记整体入口：ConcurrentMarkThread::run

do_marking_step的执行有时间限制，到了时间点就停止标记，把已标记的处理掉。

CMTask
_curr_region  年轻代的Region
