Remembered Set数据结构用于记录跨代Java对象间的引用，具体为：

1、老年代分区内的Java对象到年轻代分区内的Java对象的引用需要记录，在YGC过程中，回收的是年轻代中的不再使用的Java对象，除了以Java线程栈上的引用变量为根去深度遍历年轻代中的对象外，还要以老年代对象为根去遍历年轻代中的对象。但老年代空间远大于年轻代空间，不可能对老年代的所有对象全部扫描一遍，因此使用空间换时间的算法，为每一个年轻代的Region新建一个Remembered Set数据结构，在Remembered Set中记录引用了该年轻代Region中对象的老年代对象所处的card在全局卡表中的索引。在YGC过程中，不用去扫描老年代，直接从每个年轻代的Remembered Set出发，就能找到所有引用了年轻代对象的老年代对象（先找到老年代对象所处的card，再从card中寻找引用了年轻代对象的老年代对象），并以这些老年代对象为根再去深度遍历年轻代中的对象。

2、老年代分区内的Java对象到老年代分区内的Java对象的引用也需要记录，为了在Full GC过程中加快引用者对象的扫描速度。

3、年轻代分区内的Java对象到年轻代分区内的Java对象的引用、年轻代分区内的Java对象到老年代分区内的Java对象的引用都不需要记录，因为YGC、Full GC过程都会遍历全部年轻代内存空间，每个年轻代内的Java对象都会被遍历到，所以不需要Remembered Set了。

Remembered Set与卡表相关，卡表（card table）的概念为，在G1中，每一个HeapRegion又分为若干card，每一个card占据空间为512字节，并且维护一个全局卡表，即card table，卡表是一个整型数组，每一个int元素都对应一个card，int值表示card的当前状态（脏card表示card中的对象的引用发生了变化），每一个card的地址值除以512就是该card对应的int元素在卡表中的索引号。

以下图为例，代际引用关系为：

年轻代对象obj_1引用年轻代对象obj_3

年轻代对象obj_6引用老年代对象obj_15

年轻代对象obj_9引用年轻代对象obj_2

老年代对象obj_10引用年轻代对象obj_3

老年代对象obj_12引用年轻代对象obj_5

年轻代对象obj_16引用年轻代对象obj_7

老年代对象obj_17引用老年代对象obj_11

<img src="../images/rset_1.png" width="100%" height="100%"/>

根据上述Remembered Set记录引用的规则，在年轻代1的Remembered Set中记录card 5和card 6的卡表索引，在年轻代2的Remembered Set中记录card 8的卡表索引，在老年代1的Remembered Set中记录card 8的卡表索引。从obj_1、obj_6、obj_9出发的引用均不需要记录。
